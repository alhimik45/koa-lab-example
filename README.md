# Инструменты и ссылки
## Ссылки на скачивание инструментов и примеров
- [Простой пример лабораторной](https://github.com/alhimik45/koa-lab-example)
- [Ссылка на скачивание NodeJs](http://nodejs.org/download)

## Ссылки на документацию
- [Репозиторий и пакетный менеджер NPM](https://www.npmjs.org/)
- [Документация по Node.js](http://nodejs.org/api/)

## Учебники (дополнительная литература)
- [Учебник для начинающих по Node.js](http://nodebeginner.ru/)
- [Интерактивный учебник продвинутого уровня Node.js](http://nodeschool.io/)
- [Документация по фреймворку KoaJs](http://koajs.com/)
- [Как использовать модуль маршрутизации koa-router](https://github.com/alexmingoia/koa-router)
- [Раздача статических файлов с помощью koa-static](https://github.com/koajs/static)
- [Документация по модулю koa-body](https://github.com/dlau/koa-body)
- [Использования модуля рендера шаблонов](https://github.com/queckezz/koa-views), ([Список поддерживаемых шаблонизаторов](https://github.com/tj/consolidate.js#supported-template-engines))
- [Документация по библиотеке для запросов к MySQL](https://github.com/mysqljs/mysql)
- [Удобная обёртка над библиотекой выше](https://github.com/lukeb-uk/node-promise-mysql)

# Краткая теория
**Node.js** - программная платформа, основанная на javascript движке V8, превращающая JavaScript из узкоспециализированного языка в язык общего назначения. V8 JavaScript Engine - движок JavaScript, используемый в браузере Chrome. В основе Node.js лежит событийно-ориентированное и асинхронное (или реактивное) программирование с неблокирующим вводом/выводом.

За установку модулей в Node.js отвечает установщик пакетов **npm** (node package manager).
Для выполнения лабораторной работы потребуются следующие плагины Node.js.
- **koa** - web-фреймворк для обработки http-запросов.
- **koa-router** - модуль для обработки запросов в зависимости от пути.
- **koa-static** - модуль для подключения статических ресурсов.
- **koa-body** - модуль для получения тела запроса в виде javascript-объекта.
- **koa-views** - модуль для универсальной работы с любыми шаблонизаторами: twig, pug, handlebars, и т. д.
- **promise-mysql** - promise обёртка над DBAL для работы с mysql.

Подробнее про эти модули вы можете прочитать в документации.

#### Модель работы NodeJs

Изначально поддержка асинхронности в NodeJs была только с помощью так называемых _функций обратного вызова_ (callback, коллбек). При их использовании программист вызывал какое-то асинхронное действие и передавал в него функцию, которую необходимо было вызвать после окончания этого действия. Выглядело это примерно так:
```javascript
//записать имена всех питомцев пользователя в файл
function writeUsersPetsToFile(userтфьу, filename, cb) {
  db.query("SELECT * from Users WHERE username = ?", [username], function (err, user) {
    if (err) {
      cb(new Error("We are failed"))
    } else {
      db.query("SELECT * from Pet WHERE user_id = ?", [user.id], function (err, pets) {
        if (err) {
          cb(new Error("We are failed"))
        } else {
          fs.write(filename, pets.map(p => p.name), function(err) {
            if(err) {
              cb(new Error("We are failed"))
            } else {
              cb(null)
            }
          })
        }
      })
    }
  })
}
```
Несмотря на то, что на волне популярности NodeJs многие хвалили этот подход, на самом деле у него было несколько объективных недостатков.

> "коллбечная модель — это не просто шаг назад. Это сели на мотоцикл и
> быстро-быстро поехали обратно в лохматые 70-е"
 (с) Максим Лапшин, основатель компании Flussonic

1. Неудобная обработка ошибок: нельзя было просто бросить исключение. При написании асинхронной функции необходимо было вызывать следующий коллбек с первым аргументом `null `, если ошибки не было и с объектом ошибки, если она была. При этом, в коллбеках было нужно всё время проверять этот первый аргумент и реагировать на его содержание. При таком подходе была высока вероятность просто забыть в какой-нибудь функции проверить аргумент и просто пропустить ошибку, что не добавляло системе надежности.
2. Трудность программирования циклов и условий разной вложенности. Обычно для создания циклов использовалась рекурсия или специальные библиотеки, заворачивающие рекурсию в более удобный интерфейс. Однако, в любом случае, асинхронная модель программирования потока выполнения существенно отличалась от синхронной.
3. Трудная читаемость кода, основанного на коллбеках. Из-за высокой вложенности и нетривиальных  циклов, понимать логику такого кода было сложнее, чем синхронного. Такое положение дел назвали _callback hell_.

Когда стало понятно, что коллбеков недостаточно для ясного выражения алгоритмов в сложных программах, был создан стандарт объектов, представляющих состояние асинхронной операции - [Promises](https://learn.javascript.ru/promise) (обещания, промисы).

Код в стиле промисов уже не обладает глубокой вложенностью, в нём поддерживается бросание ошибок через `throw`, хотя для обработки ошибок нужно писать отдельные функции:

```javascript
//записать имена всех питомцев пользователя в файл
function writeUsersPetsToFile(username, filename) {
  return db.query("SELECT * from Users WHERE username = ?", [username])
  .then(function (user) {
    return db.query("SELECT * from Pet WHERE user_id = ?", [user.id])
  })
  .then(function (pets) {
    return fs.write(filename, pets.map(p => p.name))
  })
  .catch(function (err) {
    throw new Error("We are failed")
  })
}
```

Дальнейшим развитием стала поддержка промисов на уровне движка js с помощью ключевых слов `async` и `await`.

`async` в определении функции говорит о том, что она вызывает асинхронные операции и возвращает промис. Ключевое слово `await`  подписанное к какому-либо значению возвращает это значение, а если это промис, то возвращает результат его выполнения:

```javascript
//записать имена всех питомцев пользователя в файл
function writeUsersPetsToFile(username, filename) {
  try{
    var user = await db.query("SELECT * from Users WHERE username = ?", [username])
    var pets = await db.query("SELECT * from Pet WHERE user_id = ?", [user.id])
    await fs.write(filename, pets.map(p => p.name))
  } catch(e) {
    throw new Error("We are failed")
  }
}
```

Как видно, такой подход отличается от синхронного программирования лишь несколькими ключевыми словами, сохраняя все преимущества асинхронного подхода.

Именно данный подход используется в фреймворке Koa.

Koa основан на паттерне Middleware. При получении http-запроса, koa направляет его по цепочке обработчиков. Каждый из обработчиков является асинхронной функцией и может просмотреть данные запроса, записать какие-либо данные для последующих обработчиков и передать управление следующему обработчику, или же вернуть результат.

# Порядок выполнения

1. [Скачать](http://nodejs.org/download) и установить NodeJs и Npm.
2. Создать папку, в которой будет находиться приложение
3. В папке приложения создать файл `package.json` со следующим содержанием:
```json
{
  "name": "koa_lab_nodejs",
  "version": "0.0.1",
  "description": "Node JS laboratory",
  "dependencies": {},
  "author": "Alexey Kolpakov <mail@alhimik.me>",
  "license": "MIT"
}
```
4. Установить необходимые модули: в папке приложения, в консоли написать 
```bash
npm install koa koa-router koa-static koa-body koa-views promise-mysql
```
После выполнения данной команды эти модули будут установлены, их названия и версии будут внесены в раздел `dependencies` в файле `package.json`, появится каталог `./node_modules`, содержащий все зависимости проекта. Их также можно посмотреть с помощью команды `npm ls`.

5.  Также, необходимо установить шаблонизатор. Для Twig установка будет выполнена так: `npm install twig`, для Swig: `npm install swig-templates`, для других аналогично.
6. Теперь определим структуру проекта. Создадим каталог с представлениями `views` и папку для статических ресурсов `static`:
```bash
mkdir views
mkdir static
```
7. Создадим главный файл приложения (например, назовём его `app.js`), а также шаблоны с использованием выбранного шаблонизатора.
8. Запишем в главный файл простейший сервер:
```javascript
const views = require('koa-views')
const Koa = require('koa')
const Router = require('koa-router')
const serve = require('koa-static')
const koaBody = require('koa-body')

const koa = new Koa() // создаём сервер
const app = new Router(); // создаём роутер
(async function() {
	const conn = await mysql.createConnection({ // получаем подключение к базе
		host: 'localhost',
		user: 'user',
		password: 'password',
		database: 'dbname'
	})
	koa.use(serve('./static')); //регистрируем middleware, которое будет возвращать статические сайты
	koa.use(views(__dirname + '/views', { //регистрируем middleware для обработки шаблонов
		map: {
			html: 'swig' // указываем, что файлы с расширением html обрабатываются шаблонизатором swig
		}
	}))
	koa.use(koaBody()); //регистрируем middleware для парсинга тела запроса
	//обработчик маршрута /
	app.get('/', async ctx => {
		// запрос к БД
		const students = await conn.query(`SELECT * FROM students`)
		//рендер шаблона
		await ctx.render('students.html', {
			students: students
		})
	})
	//регистрируем обработчики маршрутов
	koa.use(app.routes())
	//запускаем сервер на прослушивание порта
	koa.listen(3001)
})()
```

В обработчике маршрута идёт асинхронный запрос к базе данных. То есть, после начала запроса, выполнение данной функции приостанавливается, и пока база данных обрабатывает запрос, сервер Nodejs свободен и может выполнять другие операции. Как только сервер Nodejs получит ответ от базы, выполнение данной функции продолжится.
